# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title AD_frequency
#' @name AD_frequency
#' @rdname AD_frequency
#'
#' @description
#' Create allele frequencies from matrices of allelic depths (AD)
#'
#' @param ad a matrix of allele depths (e.g., "7,2")
#' @param allele which (1-based) allele to report frequency for
#' @param sum_type type of sum to calculate, see details
#' @param delim character that delimits values
#' @param decreasing should the values be sorted decreasing (1) or increasing (0)?
#'
#' @details
#' Files containing VCF data frequently include data on allelic depth (e.g., AD).
#' This is the number of times each allele has been sequenced.
#' Our naive assumption for diploids is that these alleles should be observed at a frequency of 1 or zero for homozygous positions and near 0.5 for heterozygous positions.
#' Deviations from this expectation may indicate allelic imbalance or ploidy differences.
#' This function is intended to facilitate the exploration of allele frequencies for all positions in a sample.
#'
#' The alleles are sorted by their frequency within the function.
#' The user can then specify is the would like to calculate the frequency of the most frequent allele (allele = 1), the second most frequent allele (allele = 2) and so one.
#' If an allele is requested that does not exist it should result in NA for that position and sample.
#'
#' There are two methods to calculate a sum for the denominator of the frequency.
#' When sum_type = 0 the alleles are sorted decendingly and the first two allele counts are used for the sum.
#' This may be useful when a state of diploidy may be known to be appropriate and other alleles may be interpreted as erroneous.
#' When sum_type = 1 a sum is taken over all the observed alleles for a variant.
#'
#' @return A numeric matrix of frequencies
#' 
#' @examples
#' set.seed(999)
#' x1 <- round(rnorm(n=9, mean=10, sd=2))
#' x2 <- round(rnorm(n=9, mean=20, sd=2))
#' ad <- matrix(paste(x1, x2, sep=","), nrow=3, ncol=3)
#' colnames(ad) <- paste('Sample', 1:3, sep="_")
#' rownames(ad) <- paste('Variant', 1:3, sep="_")
#' ad[1,1] <- "9,23,12"
#' AD_frequency(ad=ad)
#' 
#' 
#' @export
AD_frequency <- function(ad, delim = ",", allele = 1L, sum_type = 0L, decreasing = 1L) {
    .Call('vcfR_AD_frequency', PACKAGE = 'vcfR', ad, delim, allele, sum_type, decreasing)
}

extract_GT_to_CM <- function(x, element = "DP") {
    .Call('vcfR_extract_GT_to_CM', PACKAGE = 'vcfR', x, element)
}

extract_GT_to_CM2 <- function(fix, gt, element = "DP", allele_sep = '/', alleles = 0L, extract = 1L) {
    .Call('vcfR_extract_GT_to_CM2', PACKAGE = 'vcfR', fix, gt, element, allele_sep, alleles, extract)
}

CM_to_NM <- function(x) {
    .Call('vcfR_CM_to_NM', PACKAGE = 'vcfR', x)
}

extract_haps <- function(ref, alt, gt, gt_split, verbose) {
    .Call('vcfR_extract_haps', PACKAGE = 'vcfR', ref, alt, gt, gt_split, verbose)
}

#' 
#' @rdname freq_peak
#' 
#' @title freq_peak
#' @description Find peaks in frequency data.
#' 
#' @param myMat a matrix of frequencies [0-1].
#' @param pos a numeric vector describing the position of variants in myMat.
#' @param winsize sliding window size.
#' @param bin_width Width of bins to summarize ferequencies in (0-1].
#' @param count logical specifying to count the number of non-NA values intead of reporting peak.
#' 
#' @details
#' More to come.
#' 
#' @return 
#' A list
#' 
#' @examples
#' freqs <- matrix(runif(n=9), ncol=3, nrow=3)
#' pos <- 1:3
#' myPeaks <- freq_peak(freqs, pos)
#' 
#' data(vcfR_example)
#' ad <- extract.gt(vcf, element = "AD")
#' ad1 <- masplit(ad, record = 1)
#' ad2 <- masplit(ad, record = 2)
#' freqs <- ad1/(ad1+ad2)
#' # myPeaks <- freq_peak(freqs, getPOS(vcf))
#' myPeaks <- freq_peak(freqs[1:115,], getPOS(vcf)[1:115])
#' 
#' # Visualize
#' mySample <- "P17777us22"
#' myWin <- 1
#' hist(freqs[myPeaks$wins[myWin,'START_row']:myPeaks$wins[myWin,'END_row'], mySample], 
#'      breaks=seq(0,1,by=0.02), col=8, main="", xlab="", xaxt="n")
#' axis(side=1, at=c(0,0.25,0.333,0.5,0.666,0.75,1), 
#'      labels=c(0,'1/4','1/3','1/2','2/3','3/4',1), las=3)
#' abline(v=myPeaks$peaks[myWin,mySample], col=2, lwd=2)
#' 
#' 
#' @export
freq_peak <- function(myMat, pos, winsize = 10000L, bin_width = 0.02, count = FALSE) {
    .Call('vcfR_freq_peak', PACKAGE = 'vcfR', myMat, pos, winsize, bin_width, count)
}

gt_to_popsum <- function(var_info, gt) {
    .Call('vcfR_gt_to_popsum', PACKAGE = 'vcfR', var_info, gt)
}

#' @rdname is_het
#' @name is_het
#' 
#' 
#' 
#' @export
is_het <- function(x, na_is_false = TRUE) {
    .Call('vcfR_is_het', PACKAGE = 'vcfR', x, na_is_false)
}

#' 
#' @rdname masplit
#' 
#' @title masplit
#' @description Split a matrix of delimited strings.
#' 
#' @param myMat a matrix of delimited strings (e.g., "7,2").
#' @param delim character that delimits values.
#' @param count return the count of delimited records.
#' @param record which (1-based) record to return.
#' @param sort should the records be sorted prior to selecting the element?
#' @param decreasing should the values be sorted decreasing (1) or increasing (0)?
#' 
#' 
#' 
#' @details Split a matrix of delimited strings.
#' 
#' @return A numeric matrix of numerics
#' 
#' 
#' @examples
#' set.seed(999)
#' x1 <- round(rnorm(n=9, mean=10, sd=2))
#' x2 <- round(rnorm(n=9, mean=20, sd=2))
#' ad <- matrix(paste(x1, x2, sep=","), nrow=3, ncol=3)
#' colnames(ad) <- paste('Sample', 1:3, sep="_")
#' rownames(ad) <- paste('Variant', 1:3, sep="_")
#' ad[1,1] <- "9,23,12"
#' is.na(ad[3,1]) <- TRUE
#' 
#' ad
#' masplit(ad, count = 1)
#' masplit(ad, sort = 0)
#' masplit(ad, sort = 0, record = 2)
#' masplit(ad, sort = 0, record = 3)
#' masplit(ad, sort = 1, decreasing = 0)
#' 
#' 
#' @export
masplit <- function(myMat, delim = ",", count = 0L, record = 1L, sort = 1L, decreasing = 1L) {
    .Call('vcfR_masplit', PACKAGE = 'vcfR', myMat, delim, count, record, sort, decreasing)
}

NM2winNM <- function(x, pos, maxbp, winsize = 100L) {
    .Call('vcfR_NM2winNM', PACKAGE = 'vcfR', x, pos, maxbp, winsize)
}

windowize_NM <- function(x, pos, starts, ends, summary = "mean") {
    .Call('vcfR_windowize_NM', PACKAGE = 'vcfR', x, pos, starts, ends, summary)
}

pair_sort <- function() {
    .Call('vcfR_pair_sort', PACKAGE = 'vcfR')
}

rank_variants <- function(variants, ends, score) {
    .Call('vcfR_rank_variants', PACKAGE = 'vcfR', variants, ends, score)
}

seq_to_rects <- function(seq, targets) {
    .Call('vcfR_seq_to_rects', PACKAGE = 'vcfR', seq, targets)
}

window_init <- function(window_size, max_bp) {
    .Call('vcfR_window_init', PACKAGE = 'vcfR', window_size, max_bp)
}

windowize_fasta <- function(wins, seq) {
    .Call('vcfR_windowize_fasta', PACKAGE = 'vcfR', wins, seq)
}

windowize_variants <- function(windows, variants) {
    .Call('vcfR_windowize_variants', PACKAGE = 'vcfR', windows, variants)
}

windowize_annotations <- function(wins, ann_starts, ann_ends, chrom_length) {
    .Call('vcfR_windowize_annotations', PACKAGE = 'vcfR', wins, ann_starts, ann_ends, chrom_length)
}

vcf_stats_gz <- function(x) {
    .Call('vcfR_vcf_stats_gz', PACKAGE = 'vcfR', x)
}

read_meta_gz <- function(x, stats, verbose) {
    .Call('vcfR_read_meta_gz', PACKAGE = 'vcfR', x, stats, verbose)
}

read_body_gz <- function(x, stats, nrows = -1L, skip = 0L, cols = 0L, verbose = 1L) {
    .Call('vcfR_read_body_gz', PACKAGE = 'vcfR', x, stats, nrows, skip, cols, verbose)
}

write_vcf_body <- function(fix, gt, filename, mask = 0L) {
    invisible(.Call('vcfR_write_vcf_body', PACKAGE = 'vcfR', fix, gt, filename, mask))
}

write_fasta <- function(seq, seqname, filename, rowlength = 80L, verbose = 1L) {
    invisible(.Call('vcfR_write_fasta', PACKAGE = 'vcfR', seq, seqname, filename, rowlength, verbose))
}

