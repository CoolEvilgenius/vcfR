# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title AD_frequency
#' @name AD_frequency
#' @rdname AD_frequency
#'
#' @description
#' Create allele frequencies from matrices of allelic depths (AD)
#'
#' @param ad a matrix of allele depths (e.g., "7,2")
#' @param allele which (1-based) allele to report frequency for
#' @param sum_type type of sum to calculate, see details
#' @param delim character that delimits values
#' @param decreasing should the values be sorted decreasing (1) or increasing (0)?
#'
#' @details
#' Files containing VCF data frequently include data on allelic depth (e.g., AD).
#' This is the number of times each allele has been sequenced.
#' Our naive assumption for diploids is that these alleles should be observed at a frequency of 1 or zero for homozygous positions and near 0.5 for heterozygous positions.
#' Deviations from this expectation may indicate allelic imbalance or ploidy differences.
#' This function is intended to facilitate the exploration of allele frequencies for all positions in a sample.
#'
#' The alleles are sorted by their frequency within the function.
#' The user can then specify is the would like to calculate the frequency of the most frequent allele (allele = 1), the second most frequent allele (allele = 2) and so one.
#' If an allele is requested that does not exist it should result in NA for that position and sample.
#'
#' There are two methods to calculate a sum for the denominator of the frequency.
#' When sum_type = 0 the alleles are sorted decendingly and the first two allele counts are used for the sum.
#' This may be useful when a state of diploidy may be known to be appropriate and other alleles may be interpreted as erroneous.
#' When sum_type = 1 a sum is taken over all the observed alleles for a variant.
#'
#' @return A numeric matrix of frequencies
#' 
#' @examples
#' set.seed(999)
#' x1 <- round(rnorm(n=9, mean=10, sd=2))
#' x2 <- round(rnorm(n=9, mean=20, sd=2))
#' ad <- matrix(paste(x1, x2, sep=","), nrow=3, ncol=3)
#' colnames(ad) <- paste('Sample', 1:3, sep="_")
#' rownames(ad) <- paste('Variant', 1:3, sep="_")
#' ad[1,1] <- "9,23,12"
#' AD_frequency(ad=ad)
#' 
#' 
#' @export
AD_frequency <- function(ad, delim = ",", allele = 1L, sum_type = 0L, decreasing = 1L) {
    .Call(`_vcfR_AD_frequency`, ad, delim, allele, sum_type, decreasing)
}

#' @export
.extract_GT_to_CM <- function(fix, gt, element = "DP", alleles = 0L, extract = 1L, convertNA = 1L) {
    .Call(`_vcfR_extract_GT_to_CM`, fix, gt, element, alleles, extract, convertNA)
}

#' @export
.CM_to_NM <- function(x) {
    .Call(`_vcfR_CM_to_NM`, x)
}

#' @export
.extract_haps <- function(ref, alt, gt, unphased_as_NA, verbose) {
    .Call(`_vcfR_extract_haps`, ref, alt, gt, unphased_as_NA, verbose)
}

#' @rdname is_het
#' @name is_het
#' 
#' 
#' 
#' @export
is_het <- function(x, na_is_false = TRUE) {
    .Call(`_vcfR_is_het`, x, na_is_false)
}

#' @export
.vcf_stats_gz <- function(x, nrows = -1L, skip = 0L) {
    .Call(`_vcfR_vcf_stats_gz`, x, nrows, skip)
}

#' @export
.read_meta_gz <- function(x, stats, verbose) {
    .Call(`_vcfR_read_meta_gz`, x, stats, verbose)
}

#' @export
.read_body_gz <- function(x, stats, nrows = -1L, skip = 0L, cols = 0L, convertNA = 1L, verbose = 1L) {
    .Call(`_vcfR_read_body_gz`, x, stats, nrows, skip, cols, convertNA, verbose)
}

#' @export
.write_vcf_body <- function(fix, gt, filename = "myFile.vcf.gz", mask = 0L) {
    invisible(.Call(`_vcfR_write_vcf_body`, fix, gt, filename, mask))
}

