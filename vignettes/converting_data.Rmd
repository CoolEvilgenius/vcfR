---
title: "Converting vcfR to other types"
author: "Brian J. Knaus"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Converting data}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---


Once we have finished examining our data in vcfR we'll want to format it so that other softwares can utilize it.
A straightforward path is to create a *.vcf.gz format file.
One downside to this path is that it creates an intermediate file.
When working on large datasets this intermediate file may be rather large.
If your path remains in R it may be preferable to convert your vcfR objects to objects defined by other packages.
Here we explore examples of these paths.


## Data import


We begin by loading the example data from the pinfsc50 package.


```{r}
library(vcfR)
vcf_file <- system.file("extdata", "pinf_sc50.vcf.gz", package = "pinfsc50")
vcf <- read.vcf(vcf_file, verbose = FALSE)
```



## Creating *.vcf.gz format files.


The function **write.vcf()** can be used to create *.vcf.gz format files (gzipped vcf files) from vcfR objects (either objects of class vcfR or chromR).


```{r, eval=FALSE}
write.vcf(vcf, "test.vcf.gz")
unlink("test.vcf.gz") # Clean up after our example is done.
```


## Creating genind objects

The packages **adegenet** and **poppr** use objects of class genind.
We can create genind objects with the function **vcfR2genind()**.


```{r genind, eval=FALSE}
my_genind <- vcfR2genind(vcf)
class(my_genind)
```


The function vcfR2genind calls extract.gt to create a matrix of genotypes.
This matrix is converted into a genind object with the adegenet function df2genind.


Currently, this function does not scale well to large quantities of data (adegenet was produced prior to high throughput sequencing).
This appears to be due to the function adegenet::df2genind and will hopefully be addressed in the future.


## Creating genclone objects


The package **poppr** uses objects of class genclone as well as genind.
Once a genind object has been created it is fairly straight forward to create a genclone object.


```{r, eval=FALSE}
my_genclone <- poppr::as.genclone(my_genind)
my_genclone
class(my_genclone)
```




## Creating genlight objects

The genlight object is used by adegenet.
It was designed specifically to handle high-throughput genotype data.
At present it appears to only support two alleles at a locus.
Variant callers such as FreeBayes and the GATK's haplotype caller currently support more than two alleles per locus, making the genlight object a suboptimal container.
The function vcfR2genlight will throw a warning (when verbose = TRUE) if it encounters loci with more than two alleles.
Loci with more than two alleles will be omitted from the genlight object.


```{r}
x <- vcfR2genlight(vcf)
```




## Creating DNAbin objects

The package **ape** handles sequence data using objects of class DNAbin.
Converting vcf data to sequence data presents a challenge in that sequence data typically includes numerous invariant sites.
This means that these objects can easily occupy large amounts of memory, and may exceed the physical memory when long sequences with many samples are included.
In order to accomodate these issues, we've taken an approach which attempts to create DNAbin objects from portions of a chomosome, such as a gene.
This means we'll need a little more information than we've needed for other conversions.
First, we'll need to locate and read in our vcf file, a reference sequence and a gff file that has the coordinates for a gene.


```{r}

#vcf_file <- system.file("extdata", "pinf_sc1_100_sub.vcf.gz", package = "vcfR")
#dna_file <- system.file("extdata", "pinf_sc100.fasta", package = "vcfR")
#gff_file <- system.file("extdata", "pinf_sc100.gff", package = "vcfR")

vcf_file <- system.file("extdata", "pinf_sc50.vcf.gz", package = "pinfsc50")
dna_file <- system.file("extdata", "pinf_sc50.fasta", package = "pinfsc50")
gff_file <- system.file("extdata", "pinf_sc50.gff", package = "pinfsc50")

vcf <- read.vcf(vcf_file, verbose = FALSE)
dna <- ape::read.dna(dna_file, format="fasta")
gff <- read.table(gff_file, sep="\t", quote = "")

```



We can use information from the annotation file (gff) to extract a gene.
Here we have specifically chosen one which has variants.
We can use IUPAC ambiguity codes to convert heterozygous sites into a one character encoding.
This results in a single sequence per individual.
Alternatively, we can create two haplotypes for each diploid sample, resulting in two sequences per individual.


```{r, tidy=TRUE}
record <- 130
my_dnabin1 <- vcfR2DNAbin(vcf, gt.split="|", ref.seq=dna[,gff[record,4]:gff[record,5]], start.pos=gff[record,4], verbose=FALSE)
my_dnabin1
```



```{r, fig.align='center', fig.width=7, fig.height=5}
par(mar=c(5,8,4,2))
ape::image.DNAbin(my_dnabin1[,ape::seg.sites(my_dnabin1)])
par(mar=c(5,4,4,2))
```


Here, the ambiguous sites are visualized as 'other.'
While the DNAbin object can include the ambiguity codes, not all downstream software handle these codes well.
So the user should excercise prudence when using this option.


If we instead create two haplotypes for each diploid sample, we result in a DNAbin object which includes only A, C,  G and T.
This typically requires the data to be phased.
In vcf files this is typically indicated by delimiting the alleles of the genotype with a pipe ('|') for phased data, while unphased data are delimited with a forward slash ('/').


```{r, tidy=TRUE}
my_dnabin1 <- vcfR2DNAbin(vcf, consensus=FALSE, extract.haps=TRUE, gt.split="|", ref.seq=dna[,gff[record,4]:gff[record,5]], start.pos=gff[record,4], verbose=FALSE)
```


```{r, fig.align='center', fig.width=7, fig.height=7}
par(mar=c(5,8,4,2))
ape::image.DNAbin(my_dnabin1[,ape::seg.sites(my_dnabin1)])
par(mar=c(5,4,4,2))
```


Once we have a DNAbin object, it can be analysed in a number of R packages, such as ape and pegas.
We can also output a fasta file for other softwares to use.

```{r, eval=FALSE}
write.dna( my_dnabin1, file = 'my_gene.fasta', format = 'fasta' )
unlink('my_gene.fasta') # Clean up after we're done
```



## Creating loci objects

The package **pegas** uses objects of class loci.
We can use the function vcfR2loci to convert our vcfR object to one of class loci.


```{r vcfR2loci}
system.time( my_loci <- vcfR2loci(vcf) )
class(my_loci)
```


This takes a noticable amount of time to execute.
But appears to work satisfactorily.
And we can now proceed to downstream analyses.


